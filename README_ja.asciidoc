= DebugTrace-java

link:README.asciidoc[[English]]

DebugTrace-javaは、Javaプログラムのデバッグ時にトレースログを出力するライブラリで、Java 8以降で利用できます。 +
メソッドの開始と終了箇所に `DebugTrace.enter()` および `DebugTrace.leave()` を埋め込む事で、開発中のJavaプログラムの実行状況をログに出力する事ができます。

=== 1. 特徴

* コール元のクラス名、メソッド名、ソースファイルおよび行番号を自動的に出力。
* メソッドやオブジェクトのネストで、ログを自動的にインデント。
* スレッドの切り替え時に自動的にログを出力。
* `toString` メソッドを実装していないクラスのオブジェクトでもリフレクションを使用して内容を出力。
* `DebugTrace.properties` で、出力内容のカスタマイズが可能。
* 実行時に依存するライブラリがない。(下記ロギング・ライブラリを使用する場合は必要)
* 各種ロギング・ライブラリを使用可能。
    ** JDKロガー
    ** Log4j
    ** Log4j2
    ** SLF4J
    ** コンソール(stdoutおよびstderr)

=== 2. 使用方法

デバッグ対象および関連するメソッドに対して以下を行います。

. メソッドの先頭に `DebugTrace.enter()` を挿入する。
. メソッドの終了(または `return` 文の直前)に `DebugTrace.leave()` を挿入する。
. 必要に応じて、引数、ローカル変数、戻り値をログに出力する `Debug.print(\...)` を挿入する。

以下は、DebugTraceのメソッドを使用したJavaの例とそれを実行した際のログです。

[source,java]
.Example1.java
----
package example;

import java.lang.reflect.Array;
import org.debugtrace.DebugTrace;

/**
 * Example1
 */
public class Example1 {
    // main
    public static void main(String[] args) {
        DebugTrace.enter(); // for DEBUGGING

        @SuppressWarnings("unused")
        Point[] points = newArray(Point.class, 2);

        DebugTrace.leave(); // for DEBUGGING
    }

    // newArray
    public static <E> E[] newArray(Class<E> elementType, int length) {
        DebugTrace.enter(); // for DEBUGGING
        DebugTrace.print("elementType", elementType); // for DEBUGGING
        DebugTrace.print("length", length); // for DEBUGGING
        @SuppressWarnings("unchecked")
        E[] array = (E[])Array.newInstance(elementType, length);
        DebugTrace.print("1 array", array); // for DEBUGGING
        try {
            for (int index = 0; index < length; ++index)
                array[index] = elementType.getConstructor().newInstance();
        }
        catch (RuntimeException e) {throw e;}
        catch (Exception e) {throw new RuntimeException(e);}
        DebugTrace.print("2 array", array); // for DEBUGGING
        DebugTrace.leave(); // for DEBUGGING
        return array;
    }

    // Point class
    public static class Point {
        private int x;
        private int y;
        public Point() {
        }
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
        public int getX() {return x;}
        public int getY() {return y;}
    }
}
----

.debugtrace.log
----
2018-07-29 22:57:25.251+09:00 DebugTrace 2.5.0 / logger: org.debugtrace.logger.Std$Err
2018-07-29 22:57:25.251+09:00 
2018-07-29 22:57:25.251+09:00 ______________________________ main ______________________________
2018-07-29 22:57:25.251+09:00 
2018-07-29 22:57:25.251+09:00 Enter example.Example1.main (Example1.java:15)
2018-07-29 22:57:25.265+09:00 | Enter example.Example1.newArray (Example1.java:25)
2018-07-29 22:57:25.265+09:00 | | elementType = (Class)class example.Example1$Point (Example1.java:26)
2018-07-29 22:57:25.265+09:00 | | length = 2 (Example1.java:27)
2018-07-29 22:57:25.265+09:00 | | 1 array = (example.Example1.Point[2])[
2018-07-29 22:57:25.265+09:00 | |   null,
2018-07-29 22:57:25.265+09:00 | |   null,
2018-07-29 22:57:25.265+09:00 | | ] (Example1.java:30)
2018-07-29 22:57:25.265+09:00 | | 2 array = (example.Example1.Point[2])[
2018-07-29 22:57:25.265+09:00 | |   (example.Example1.Point)[
2018-07-29 22:57:25.265+09:00 | |     x: 0,
2018-07-29 22:57:25.265+09:00 | |     y: 0,
2018-07-29 22:57:25.265+09:00 | |   ],
2018-07-29 22:57:25.265+09:00 | |   (example.Example1.Point)[
2018-07-29 22:57:25.265+09:00 | |     x: 0,
2018-07-29 22:57:25.265+09:00 | |     y: 0,
2018-07-29 22:57:25.265+09:00 | |   ],
2018-07-29 22:57:25.265+09:00 | | ] (Example1.java:37)
2018-07-29 22:57:25.265+09:00 | Leave example.Example1.newArray (Example1.java:38)
2018-07-29 22:57:25.265+09:00 Leave example.Example1.main (Example1.java:20)
----

=== 3. メソッド一覧

このライブラリには以下のメソッドがあります。すべてorg.debugtrace.DebugTraceクラスの静的メソッドで、戻り値なしです。

[options="header"]
.メソッド一覧
|===
|メソッド名|引 数|処理概要
|`enter`
|なし
|メソッドの開始をログに出力する

|`leave`
|なし
|メソッドの終了をログに出力する

|`print`
|`message`: メッセージ
|メッセージをログに出力する

|`print`
|`messageSupplier`: メッセージのサプライヤー
|サプライヤーからメッセージを取得してログに出力する

|`print`
|`name`: 値の名前 +
`value`: 値
|`<値の名前> = <値>` +
の形式でログに出力する +
value のタイプは `boolean`, `char`, `byte`, `short`, `int`, `long`, `float`, `double` または `Object`

|`print`
|`name`: 値の名前 +
`valueSupplier`: 値のサプライヤー
|サプライヤーから値を取得して +
`<値の名前> = <値>` +
の形式でログに出力する +
valueSupplier のタイプは `BooleanSupplier`, `IntSupplier`, `LongSupplier` または `Supplier<T>`

|`print`
[.small]#_[v2.4.0~]_#
|`mapName`: 数値に対応する定数名を得るためのマップの名前 +
`name`: 値の名前 +
`value`: 出力値
|`<値の名前> = <値>(<定数名>)` +
の形式でログに出力する +
valueのタイプは `byte`, `short`, `int`, `long` または `Object`

|`print`
[.small]#_[v2.4.0~]_#
|`mapName`: 数値に対応する定数名を得るためのマップの名前 +
`name`: 値の名前 +
`valueSupplier`: 値のサプライヤー
|サプライヤーから値を取得して +
`<値の名前> = <値>(<定数名>)` +
の形式でログに出力する +
valueSupplierのタイプは `IntSupplier`, `LongSupplier` または `Supplier<T>`

|===

=== 4. *DebugTrace.properties* ファイルのプロパティ

DebugTrace は、クラスパスにある `DebugTrace.properties` ファイルを起動時に読み込みます。
`DebugTrace.properties` ファイルには以下のプロパティを指定できます。

[options="header", cols="2,8"]
.DebugTrace.properties
|===
|プロパティ名|説明
|`logger`
| DebugTrace が使用するロガー +
[.small]#*設定例:*# +
&#160;&#160; `logger = Std$Out` [.small .blue]#- stdout へ出力 *_(デフォルト ~v2.4.6 )_*# +
&#160;&#160; `logger = Std$Err` [.small .blue]#- stderr へ出力 *_(デフォルト v2.5.0~ )_*# +
&#160;&#160; `logger = Jdk` [.small .blue]#- JDKロガー を使用# +
&#160;&#160; `logger = Log4j` [.small .blue]#- Log4j を使用# +
&#160;&#160; `logger = Log4j2` [.small .blue]#- Log4j2 を使用# +
&#160;&#160; `logger = SLF4J` [.small .blue]#- SLF4J を使用# +

|`logLevel`
|使用するログレベル +
[.small]#*JDKを使用する際の設定例:*# +
&#160;&#160; `logLevel = default` [.small .blue]#- finestと同じ *_(デフォルト)_*# +
&#160;&#160; `logLevel = finest` +
&#160;&#160; `logLevel = finer` +
&#160;&#160; `logLevel = fine` +
&#160;&#160; `logLevel = config` +
&#160;&#160; `logLevel = info` +
&#160;&#160; `logLevel = warning` +
&#160;&#160; `logLevel = severe` +
[.small]#*Log4j, Lo4j2を使用する際の設定例:*# +
&#160;&#160; `logLevel = default` [.small .blue]#- trace と同じ *_(デフォルト)_*# +
&#160;&#160; `logLevel = trace` +
&#160;&#160; `logLevel = debug` +
&#160;&#160; `logLevel = info` +
&#160;&#160; `logLevel = warn` +
&#160;&#160; `logLevel = error` +
&#160;&#160; `logLevel = fatal` +
[.small]#*SLF4Jを使用する際の設定例:*# +
&#160;&#160; `logLevel = default` [.small .blue]#- trace と同じ *_(デフォルト)_*# +
&#160;&#160; `logLevel = trace` +
&#160;&#160; `logLevel = debug` +
&#160;&#160; `logLevel = info` +
&#160;&#160; `logLevel = warn` +
&#160;&#160; `logLevel = error` +

|`enterString`
|`enter` メソッドで出力される文字列 +
[.small]#*設定例:*# +
&#160;&#160; `enterString = Enter %1$s.%2$s (%3$s:%4$d)` [.small .blue]#*_(デフォルト)_*# +
[.small]#*パラメータ:*# +
&#160;&#160; `%1`: 呼出側のクラス名 +
&#160;&#160; `%2`: 呼出側のメソッド名 +
&#160;&#160; `%3`: 呼出側のファイル名 +
&#160;&#160; `%4`: 呼出側の行番号 +

|`leaveString`
|`leave` メソッドで出力される文字列 +
[.small]#*設定例:*# +
&#160;&#160; `leaveString = Leave %1$s.%2$s (%3$s:%4$d)`  [.small .blue]#*_(デフォルト)_*# +
[.small]#*パラメータ:*# +
&#160;&#160; `%1`: 呼出側のクラス名 +
&#160;&#160; `%2`: 呼出側のメソッド名 +
&#160;&#160; `%3`: 呼出側のファイル名 +
&#160;&#160; `%4`: 呼出側の行番号 +

|`threadBoundaryString`
|スレッド境界で出力される文字列 +
[.small]#*設定例:*# +
&#160;&#160; [.small]`threadBoundaryString = \____\__\__\__\__\__\__\__\__\__\__\__\__\__ %1$s \__\__\__\__\__\__\__\__\__\__\__\__\__\____`# +
&#160;&#160; [.small .blue]#*_(デフォルト)_*# +
[.small]#*パラメータ:*# +
&#160;&#160; `%1`: スレッド名 +

|`classBoundaryString`
|クラス境界での出力文字列 +
[.small]#*設定例:*# +
&#160;&#160; `classBoundaryString = \\____ %1$s \____` [.small .blue]#*_(デフォルト)_*# +
[.small]#*パラメータ:*# +
`%1`: クラス名 +

|`indentString`
|コードのインデント文字列 +
[.small]#*設定例:*# +
&#160;&#160; `indentString = &#x7c;\\s` [.small .blue]#*_(デフォルト)_*# +
&#160;&#160; [.small .blue]#`\\s` は空白文字に置き換えられる# +

|`dataIndentString`
|データのインデント文字列 +
[.small]#*設定例:*# +
&#160;&#160; `dataIndentString = \\s\\s` +
&#160;&#160; [.small .blue]#`\\s` は空白文字に置き換えられる# +

|`limitString`
|制限を超えた場合の出力文字列 +
[.small]#*設定例:*# +
&#160;&#160; `limitString = \...` [.small .blue]#*_(デフォルト)_*# +

|`nonPrintString` +
[.small]#_(v1.5.0~)_#
|出力しないプロパティ値の文字列 +
[.small]#*設定例:*# +
&#160;&#160; `nonPrintString = \***` [.small .blue]#*_(デフォルト)_*# +

|`cyclicReferenceString`
|循環参照時の出力文字列 +
[.small]#*設定例:*# +
&#160;&#160; `cyclicReferenceString = \\s\*\** cyclic reference \***\\s` [.small .blue]#*_(デフォルト)_*# +
&#160;&#160; [.small .blue]#`\\s` は空白文字に置き換えられる# +

|`varNameValueSeparator`
|変数名と値のセパレータ +
[.small]#*設定例:*# +
&#160;&#160; `varNameValueSeparator = \\s=\\s` +
&#160;&#160; [.small .blue]#`\\s` は空白文字に置き換えられる# +

|`keyValueSeparator`
|マップのキーと値のセパレータ +
[.small]#*設定例:*# +
&#160;&#160; `keyValueSeparator = :\\s` [.small .blue]#*_(デフォルト)_*# +
[.small .blue]#`\\s` は空白文字に置き換えられる# +

|`fieldNameValueSeparator`
|フィールド名と値のセパレータ +
[.small]#*設定例:*# +
&#160;&#160; `fieldNameValueSeparator = :\\s` +
&#160;&#160; [.small .blue]#`\\s` は空白文字に置き換えられる# +

|`printSuffixFormat`
|`print` メソッドで付加される文字列 +
[.small]#*設定例:*# +
&#160;&#160; `printSuffixFormat = \\s(%3$s:%4$d)` +
&#160;&#160; [.small .blue]#`\\s` は空白文字に置き換えられる# +
[.small]#*パラメータ:*# +
&#160;&#160; `%1`: 呼出側のクラス名 +
&#160;&#160; `%2`: 呼出側のメソッド名 +
&#160;&#160; `%3`: 呼出側のファイル名 +
&#160;&#160; `%4`: 呼出側の行番号 +

|`utilDateFormat`
|`java.util.Date` の出力フォーマット +
[.small]#*設定例:*# [.small yellow-background]#_[~v2.4.6]_# +
&#160;&#160; `utilDateFormat = %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS` [.small .blue]#*_(デフォルト)_*# +
[.small]#*パラメータ:*# +
&#160;&#160; `%1`: `java.util.Date` オブジェクト +
 +
[.small]#*設定例:*# [.small lime-background]#_[v2.5.0~]_# +
`utilDateFormat = yyyy-MM-dd HH:mm:ss.SSSxxx` [.small .blue]#*_(デフォルト)_*# +

|`sqlDateFormat`
|`java.sql.Date` の出力フォーマット +
[.small]#*設定例:*# [.small yellow-background]#_[~v2.4.6]_# +
&#160;&#160; `sqlDateFormat = %1$tY-%1$tm-%1$td` [.small .blue]#*_(デフォルト)_*# +
[.small]#*パラメータ:*# +
&#160;&#160; `%1`: `java.sql.Date` オブジェクト +
 +
[.small]#*設定例:*# [.small lime-background]#_[v2.5.0~]_# +
`sqlDateFormat = yyyy-MM-ddxxx` [.small .blue]#*_(デフォルト)_*# +

|`timeFormat`
|`java.sql.Time` の出力フォーマット +
[.small]#*設定例:*# [.small yellow-background]#_[~v2.4.6]_# +
&#160;&#160; `timeFormat = %1$tH:%1$tM:%1$tS` [.small .blue]#*_(デフォルト)_*# +
[.small]#*パラメータ:*# +
&#160;&#160; `%1`: `java.sql.Time` オブジェクト +
 +
[.small]#*設定例:*# [.small lime-background]#_[v2.5.0~]_# +
&#160;&#160; `timeFormat = HH:mm:ss.SSSxxx` [.small .blue]#*_(デフォルト)_*# +

|`timestampFormat`
|`java.sql.Timestamp` の出力フォーマット +
[.small]#*設定例:*# [.small yellow-background]#_[~v2.4.6]_# +
&#160;&#160; `timestampFormat = %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS.%1$tL` [.small .blue]#*_(デフォルト)_*# +
[.small]#*パラメータ:*# +
&#160;&#160; `%1`: `java.sql.Timestamp` オブジェクト +
 +
[.small]#*設定例:*# [.small lime-background]#_[v2.5.0~]_# +
&#160;&#160; `timestampFormat = yyyy-MM-dd HH:mm:ss.SSSSSSSSSxxx` [.small .blue]#*_(デフォルト)_*# +

|`localDateFormat` +
[.small lime-background]#_[v2.5.0~]_#
|`java.time.LocalDate` の出力フォーマット +
[.small]#*設定例:*# +
&#160;&#160; `localDateFormat = yyyy-MM-dd` [.small .blue]#*_(デフォルト)_*# +

|`localTimeFormat` +
[.small lime-background]#_[v2.5.0~]_#
|`java.time.LocalTime` の出力フォーマット +
[.small]#*設定例:*# +
&#160;&#160; `localTimeFormat = HH:mm:ss.SSSSSSSSS` [.small .blue]#*_(デフォルト)_*# +

|`offsetTimeFormat` +
[.small lime-background]#_[v2.5.0~]_#
|`java.time.OffsetTime` の出力フォーマット +
[.small]#*設定例:*# +
&#160;&#160; `offsetTimeFormat = offsetTimeFormat = HH:mm:ss.SSSSSSSSSxxx` [.small .blue]#*_(デフォルト)_*# +

|`localDateTimeFormat` +
[.small lime-background]#_[v2.5.0~]_#
|`java.time.LocalDateTime` の出力フォーマット +
[.small]#*設定例:*# +
&#160;&#160; `localDateTimeFormat = yyyy-MM-dd HH:mm:ss.SSSSSSSSS` [.small .blue]#*_(デフォルト)_*# +

|`offsetDateTimeFormat` +
[.small lime-background]#_[v2.5.0~]_#
|`java.time.OffsetDateTime` の出力フォーマット +
[.small]#*設定例:*# +
&#160;&#160; `offsetDateTimeFormat = yyyy-MM-dd HH:mm:ss.SSSSSSSSSxxx` [.small .blue]#*_(デフォルト)_*# +

|`zonedDateTimeFormat` +
[.small lime-background]#_[v2.5.0~]_#
|`java.time.ZonedDateTime` の出力フォーマット +
[.small]#*設定例:*# +
&#160;&#160; `zonedDateTimeFormat = yyyy-MM-dd HH:mm:ss.SSSSSSSSSxxx VV` [.small .blue]#*_(デフォルト)_*# +

|`instantFormat` +
[.small lime-background]#_[v2.5.0~]_#
|`java.time.Instant` の出力フォーマット +
[.small]#*設定例:*# +
&#160;&#160; `instantFormat = yyyy-MM-dd HH:mm:ss.SSSSSSSSSX` [.small .blue]#*_(デフォルト)_*# +

|`logDateTimeFormat` +
[.small lime-background]#_[v2.5.0~]_#
|ロガーが `Std$Out` または `Std$Err` の際のログの日時の出力フォーマット +
[.small]#*設定例:*# +
&#160;&#160; `logDateTimeFormat = yyyy-MM-dd HH:mm:ss.SSSxxx` [.small .blue]#*_(デフォルト)_*# +

|`arrayLimit`
|配列と `Collection` 要素の出力数の制限 +
[.small]#*設定例:*# +
`arrayLimit = 512` [.small .blue]#*_(デフォルト)_*# +

|`byteArrayLimit`
|バイト配列(`byte[]`)要素の出力数の制限 +
[.small]#*設定例:*# +
&#160;&#160; `byteArrayLimit = 8192` [.small .blue]#*_(デフォルト)_*# +

|`mapLimit`
|`Map` 要素の出力制限数 +
[.small]#*設定例:*# +
&#160;&#160; `mapLimit = 512` [.small .blue]#*_(デフォルト)_*# +

|`stringLimit`
|`String` の出力文字数の制限 +
[.small]#*設定例:*# +
&#160;&#160; `stringLimit = 8192` [.small .blue]#*_(デフォルト)_*# +

|`nonPrintProperties` +
[.small]#_[v2.2.0~]_#
|出力しないプロパティのリスト +
[.small]#*設定例(値が1つ):*# +
&#160;&#160; `NonPrintProperties = org.lightsleep.helper.EntityInfo#columnInfos` +
[.small]#*設定例(値が複数):*# +
&#160;&#160; `nonPrintProperties = \` +
&#160;&#160;&#160;&#160; `org.lightsleep.helper.EntityInfo#columnInfos,\` +
&#160;&#160;&#160;&#160; `org.lightsleep.helper.EntityInfo#keyColumnInfos,\` +
&#160;&#160;&#160;&#160; `org.lightsleep.helper.ColumnInfo#entityInfo` +
&#160;&#160; [.small .blue]#デフォルトはなし# +
[.small]#*値のフォーマット:*# +
&#160;&#160; `<フルクラス名>#<プロパティ名>` +

|`defaultPackage` +
[.small]#_[v2.3.0~]_#
|使用する Javaソースのデフォルトパッケージ +
[.small]#*設定例:*# +
&#160;&#160; `defaultPackage = org.debugtrace.DebugTraceExample` +
&#160;&#160; [.small .blue]#デフォルトはなし# +

|`defaultPackageString` +
[.small]#_[v2.3.0~]_#
|デフォルトパッケージ部を置き換える文字列 +
[.small]#*設定例:*# +
&#160;&#160; `defaultPackageString = \...` [.small .blue]#*_(デフォルト)_*# +

|`reflectionClasses` +
[.small]#_[v2.4.0~]_#
|`toString` メソッドを実装していてもリフレクションで内容を出力するクラス名のリスト +
[.small]#*設定例(値が1つ):*# +
&#160;&#160; `reflectionClasses = org.debugtrce.DebugTraceExample.Point` +
[.small]#*設定例(値が複数):*# +
&#160;&#160; `reflectionClasses = \` +
&#160;&#160;&#160;&#160; `org.debugtrace.DebugTraceExample.Point,\` +
&#160;&#160;&#160;&#160; `org.debugtrace.DebugTraceExample.Rectangle` +
&#160;&#160; [.small .blue]#デフォルトはなし# +

|`mapNameMap` +
[.small]#_[v2.4.0~]_#
|変数名に対応するマップ名を取得するためのマップ +
[.small]#*設定例:*# +
&#160;&#160; `mapNameMap = appleBrand: AppleBrand` +
[.small]#*値のフォーマット:*# +
&#160;&#160; `<変数名>: <マップ名>` +
&#160;&#160; [.small .blue]#デフォルトはなし# +

|`<マップ名>` +
[.small]#_[v2.4.0~]_#
|数値(key)と数値に対応する定数名(value)のマップ +
[.small]#*設定例:*# +
&#160;&#160; `AppleBrand = \` +
&#160;&#160;&#160;&#160; `0: Apple.NO_BRAND,\` + 
&#160;&#160;&#160;&#160; `1: Apple.AKANE,\` + 
&#160;&#160;&#160;&#160; `2: Apple.AKIYO,\` + 
&#160;&#160;&#160;&#160; `3: Apple.AZUSA,\` + 
&#160;&#160;&#160;&#160; `4: Apple.YUKARI` + 
[.small]#*値のフォーマット:*# +
&#160;&#160; `<数値>: <定数名>` +
[.small]#*定義済み定数名マップ:*# +
&#160;&#160; `Calendar`: `Calendar.ERA` など +
&#160;&#160; `CalendarWeek`: `Calendar.SUNDAY` など +
&#160;&#160; `CalendarMonth`: `Calendar.JANUARY` など +
&#160;&#160; `CalendarAmPm`: `Calendar.AM` など +
&#160;&#160; `SqlTypes`: `java.sql.Types.BIT` など

|===
DebugTrace-java 2.4.6までは、日時の出力フォーマットを `String.format` の引数の形式で指定し、2.5.0以降では `DateTimeFormatter.ofPattern` の引数の形式で指定してください。

==== 4.1. *nonPrintProperties*, *nonPrintString*

DebugTrace は、 `toString` メソッドが実装されていない場合は、リフレクションを使用してオブジェクト内容を出力します。
他のオブジェクトの参照があれば、そのオブジェクトの内容も出力します。
ただし循環参照がある場合は、自動的に検出して出力を中断します。  
`nonPrintProperties` プロパティを指定して出力を抑制する事もできます。
このプロパティの値は、カンマ区切りで複数指定できます。  
`nonPrintProperties` で指定されたプロパティの値は、 `nonPrintString` で指定された文字列(デフォルト: `\***`)で出力されます。

.nonPrintProperties の例 (DebugTrace.properties)
----
nonPrintProperties = \
    org.lightsleep.helper.EntityInfo#columnInfos,\
    org.lightsleep.helper.EntityInfo#keyColumnInfos,\
    org.lightsleep.helper.ColumnInfo#entityInfo
----

==== 4.2. 定数マップ, *mapNameMap*

定数マップは、キーが数値で値が定数名のマップです。このプロパティのキー(マップ名)を `print` メソッドの引数にしてコールすると数値に定数名が付加されて出力されます。

.定数マップの例 (DebugTrace.properties)
----
AppleBrand = \
    0: Apple.NO_BRAND,\
    1: Apple.AKANE,\
    2: Apple.AKIYO,\
    3: Apple.AZUSA,\
    4: Apple.YUKARI
----

[source,java]
.Javaソースの例
----
int appleBrand = Apple.AKANE;
DebugTrace.print("AppleBrand", "appleBrand", appleBrand);
----

.Logの例
----
2017-07-29 13:45:32.489 | appleBrand = 1(Apple.AKANE) (README_example.java:29)
----

変数名に対応するマップ名を `mapNameMap` プロパティで指定すると、マップ名を指定しない場合でも定数名が出力されます。

.mapNameMap の例 (DebugTrace.properties)
----
mapNameMap = appleBrand: AppleBrand
----

[source,java]
.Javaソースの例
----
int appleBrand = Apple.AKANE;
DebugTrace.print("appleBrand", appleBrand);
appleBrand = Apple.AKIYO;
DebugTrace.print(" 2 appleBrand ", appleBrand);
appleBrand = Apple.AZUSA;
DebugTrace.print(" 3 example.appleBrand ", appleBrand);
appleBrand = Apple.YUKARI;
DebugTrace.print(" 4 example. appleBrand ", appleBrand);
----

.Log の例
----
2017-07-29 13:45:32.489 | appleBrand = 1(Apple.AKANE) (README_example.java:38)
2017-07-29 13:45:32.489 |  2 appleBrand  = 2(Apple.AKIYO) (README_example.java:40)
2017-07-29 13:45:32.489 |  3 example.appleBrand  = 3(Apple.AZUSA) (README_example.java:42)
2017-07-29 13:45:32.489 |  4 example. appleBrand  = 4(Apple.YUKARI) (README_example.java:44)
----

=== 5. ロギング・ライブラリの使用例

ロギング・ライブラリを使用する際のDebugTraceのロガー名は、 `org.debugtrace.DebugTrace` です。

==== 5-1. *logging.properties* (JDK標準) の例

.logging.properties
----
# logging.properties
handlers = java.util.logging.ConsoleHandler
java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter
java.util.logging.SimpleFormatter.format = [Jdk] %1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS.%1$tL %5$s%n
java.util.logging.ConsoleHandler.level = FINEST
org.debugtrace.DebugTrace.level = FINEST
----
*Java起動時オプションとして `-Djava.util.logging.config.file=<パス>/logging.properties` が必要*

==== 5-2. *log4j.xml* (Log4j) の例

[source,xml]
.log4j.xml
----
<!-- log4j.xml -->
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/" debug="false">
  <appender name="Console" class="org.apache.log4j.ConsoleAppender">
    <param name="Target" value="System.out"/>
    <layout class="org.apache.log4j.PatternLayout">
      <param name="ConversionPattern" value="[Log4j] %d{yyyy-MM-dd HH:mm:ss.SSS} %5p %m%n"/>
    </layout>
  </appender>
  <logger name="org.debugtrace.DebugTrace">
    <level value ="trace"/>
    <appender-ref ref="Console"/>
  </logger>
</log4j:configuration>
----

==== 5-3. *log4j2.xml* (Log4j2) の例

[source,xml]
.log4j2.xml
----
<!-- log4j2.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<configuration status="WARN">
  <appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="[Log4j2] %d{yyyy-MM-dd HH:mm:ss.SSS} %5p %msg%n"/>
    </Console>
  </appenders>
  <loggers>
    <logger name="org.debugtrace.DebugTrace" level="trace"/>
    <root level="error"><appender-ref ref="Console"/></root>
  </loggers>
</configuration>
----

==== 5-4. *logback.xml* (SLF4J/Logback) の例

[source,xml]
.logback.xml
----
<!-- logback.xml -->
<configuration>
  <appender name="Console" class="ch.qos.logback.core.ConsoleAppender">
    <encoder>
      <pattern>[SLF4J logback] %d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %msg%n</pattern>
    </encoder>
  </appender>
  <logger name="org.debugtrace.DebugTrace" level="trace"/>
  <root level="error"><appender-ref ref="Console"/></root>
</configuration>
----

=== 6. *build.gradle*の記述例

[source,groovy]
.build.gradle
----
repositories {
    jcenter()
}

dependencies {
    compile 'org.debugtrace:debugtrace:2.+'
}
----

=== 7. ライセンス

link:LICENSE.txt[MIT ライセンス(MIT)]

_(C) 2015 Masato Kokubo_

=== 8. リンク

http://masatokokubo.github.io/DebugTrace-java/javadoc_ja/index.html[API仕様]
